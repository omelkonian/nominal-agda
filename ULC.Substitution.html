<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>ULC.Substitution</title><link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css'/><style>.github-fork-ribbon:before { background-color: #333; }</style><link rel="stylesheet" href="css/Agda.css"></head><body><a class='github-fork-ribbon'href='https://github.com/omelkonian/nominal-agda/tree/master/ULC/Substitution.agda'data-ribbon='Source code on Github' title='Source code on Github'>Source code on Github</a><pre class="Agda"><a id="1" class="Comment">-- {-# OPTIONS --allow-unsolved-metas #-}</a>
<a id="43" class="Comment">-- {-# OPTIONS --auto-inline #-}</a>
<a id="76" class="Keyword">open</a> <a id="81" class="Keyword">import</a> <a id="88" href="Prelude.Init.html" class="Module">Prelude.Init</a> <a id="101" class="Keyword">hiding</a> <a id="108" class="Symbol">(</a><a id="109" href="Data.List.Base.html#5034" class="Function Operator">[_]</a><a id="112" class="Symbol">);</a> <a id="115" class="Keyword">open</a> <a id="120" href="Prelude.Init.html#504" class="Module">SetAsType</a>
<a id="130" class="Keyword">open</a> <a id="135" href="Prelude.Init.html#7118" class="Module">L.Mem</a>
<a id="141" class="Keyword">open</a> <a id="146" class="Keyword">import</a> <a id="153" href="Prelude.General.html" class="Module">Prelude.General</a>
<a id="169" class="Keyword">open</a> <a id="174" class="Keyword">import</a> <a id="181" href="Prelude.DecEq.html" class="Module">Prelude.DecEq</a>
<a id="195" class="Comment">-- open import Prelude.Lists.Dec</a>
<a id="228" class="Comment">-- open import Prelude.Measurable</a>
<a id="262" class="Keyword">open</a> <a id="267" class="Keyword">import</a> <a id="274" href="Prelude.InfEnumerable.html" class="Module">Prelude.InfEnumerable</a>
<a id="296" class="Keyword">open</a> <a id="301" class="Keyword">import</a> <a id="308" href="Prelude.Setoid.html" class="Module">Prelude.Setoid</a>
<a id="323" class="Keyword">open</a> <a id="328" class="Keyword">import</a> <a id="335" href="Prelude.InferenceRules.html" class="Module">Prelude.InferenceRules</a>

<a id="359" class="Comment">-- ** Substitution.</a>
<a id="379" class="Keyword">module</a> <a id="386" href="ULC.Substitution.html" class="Module">ULC.Substitution</a> <a id="403" class="Symbol">(</a><a id="404" href="ULC.Substitution.html#404" class="Bound">Atom</a> <a id="409" class="Symbol">:</a> <a id="411" href="Agda.Primitive.html#320" class="Primitive">Type</a><a id="415" class="Symbol">)</a> <a id="417" class="Symbol">â¦ƒ</a> <a id="419" href="ULC.Substitution.html#419" class="Bound">_</a> <a id="421" class="Symbol">:</a> <a id="423" href="Prelude.DecEq.Core.html#148" class="Record">DecEq</a> <a id="429" href="ULC.Substitution.html#404" class="Bound">Atom</a> <a id="434" class="Symbol">â¦„</a> <a id="436" class="Symbol">â¦ƒ</a> <a id="438" href="ULC.Substitution.html#438" class="Bound">_</a> <a id="440" class="Symbol">:</a> <a id="442" href="Prelude.InfEnumerable.html#663" class="Record">Enumerableâˆ</a> <a id="454" href="ULC.Substitution.html#404" class="Bound">Atom</a> <a id="459" class="Symbol">â¦„</a> <a id="461" class="Keyword">where</a>

<a id="468" class="Keyword">open</a> <a id="473" class="Keyword">import</a> <a id="480" href="ULC.Base.html" class="Module">ULC.Base</a>    <a id="492" href="ULC.Substitution.html#404" class="Bound">Atom</a> <a id="497" class="Symbol">â¦ƒ</a> <a id="499" href="Function.Base.html#4821" class="Function">it</a> <a id="502" class="Symbol">â¦„</a>
<a id="504" class="Keyword">open</a> <a id="509" class="Keyword">import</a> <a id="516" href="ULC.Measure.html" class="Module">ULC.Measure</a> <a id="528" href="ULC.Substitution.html#404" class="Bound">Atom</a> <a id="533" class="Symbol">â¦ƒ</a> <a id="535" href="Function.Base.html#4821" class="Function">it</a> <a id="538" class="Symbol">â¦„</a> <a id="540" class="Symbol">â¦ƒ</a> <a id="542" href="Function.Base.html#4821" class="Function">it</a> <a id="545" class="Symbol">â¦„</a>
<a id="547" class="Keyword">open</a> <a id="552" class="Keyword">import</a> <a id="559" href="ULC.Alpha.html" class="Module">ULC.Alpha</a>   <a id="571" href="ULC.Substitution.html#404" class="Bound">Atom</a> <a id="576" class="Symbol">â¦ƒ</a> <a id="578" href="Function.Base.html#4821" class="Function">it</a> <a id="581" class="Symbol">â¦„</a> <a id="583" class="Symbol">â¦ƒ</a> <a id="585" href="Function.Base.html#4821" class="Function">it</a> <a id="588" class="Symbol">â¦„</a>
<a id="590" class="Keyword">open</a> <a id="595" class="Keyword">import</a> <a id="602" href="Nominal.html" class="Module">Nominal</a> <a id="610" href="ULC.Substitution.html#404" class="Bound">Atom</a>
<a id="615" class="Keyword">open</a> <a id="620" class="Keyword">import</a> <a id="627" href="Nominal.Product.html" class="Module">Nominal.Product</a> <a id="643" href="ULC.Substitution.html#404" class="Bound">Atom</a>

<a id="649" class="Comment">-- enforce the Barendregt convention: no shadowing, distinct bound variables</a>
<a id="726" class="Symbol">{-#</a> <a id="730" class="Keyword">TERMINATING</a> <a id="742" class="Symbol">#-}</a>
<a id="barendregt"></a><a id="746" href="ULC.Substitution.html#746" class="Function">barendregt</a> <a id="757" class="Symbol">:</a> <a id="759" href="Algebra.Core.html#484" class="Function">Opâ‚</a> <a id="763" href="ULC.Base.html#356" class="Datatype">Term</a>
<a id="768" href="ULC.Substitution.html#746" class="Function">barendregt</a> <a id="779" class="Symbol">=</a> <a id="781" href="ULC.Substitution.html#799" class="Function">go</a> <a id="784" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a>
  <a id="789" class="Keyword">where</a>
    <a id="799" href="ULC.Substitution.html#799" class="Function">go</a> <a id="802" class="Symbol">:</a> <a id="804" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="809" href="ULC.Substitution.html#404" class="Bound">Atom</a> <a id="814" class="Symbol">â†’</a> <a id="816" href="Algebra.Core.html#484" class="Function">Opâ‚</a> <a id="820" href="ULC.Base.html#356" class="Datatype">Term</a>
    <a id="829" href="ULC.Substitution.html#799" class="Function">go</a> <a id="832" href="ULC.Substitution.html#832" class="Bound">xs</a> <a id="835" class="Symbol">=</a> <a id="837" class="Symbol">Î»</a> <a id="839" class="Keyword">where</a>
      <a id="851" class="Symbol">(</a><a id="852" href="ULC.Base.html#376" class="InductiveConstructor Operator">`</a> <a id="854" href="ULC.Substitution.html#854" class="Bound">x</a><a id="855" class="Symbol">)</a>     <a id="861" class="Symbol">â†’</a> <a id="863" href="ULC.Base.html#376" class="InductiveConstructor Operator">`</a> <a id="865" href="ULC.Substitution.html#854" class="Bound">x</a>
      <a id="873" class="Symbol">(</a><a id="874" href="ULC.Substitution.html#874" class="Bound">l</a> <a id="876" href="ULC.Base.html#396" class="InductiveConstructor Operator">Â·</a> <a id="878" href="ULC.Substitution.html#878" class="Bound">r</a><a id="879" class="Symbol">)</a>   <a id="883" class="Symbol">â†’</a> <a id="885" href="ULC.Substitution.html#799" class="Function">go</a> <a id="888" href="ULC.Substitution.html#832" class="Bound">xs</a> <a id="891" href="ULC.Substitution.html#874" class="Bound">l</a> <a id="893" href="ULC.Base.html#396" class="InductiveConstructor Operator">Â·</a> <a id="895" href="ULC.Substitution.html#799" class="Function">go</a> <a id="898" href="ULC.Substitution.html#832" class="Bound">xs</a> <a id="901" href="ULC.Substitution.html#878" class="Bound">r</a>
      <a id="909" class="Symbol">(</a><a id="910" href="ULC.Base.html#748" class="InductiveConstructor Operator">Æ›</a> <a id="912" href="ULC.Substitution.html#912" class="Bound">x</a> <a id="914" href="ULC.Base.html#748" class="InductiveConstructor Operator">â‡’</a> <a id="916" href="ULC.Substitution.html#916" class="Bound">t</a><a id="917" class="Symbol">)</a> <a id="919" class="Symbol">â†’</a> <a id="921" class="Keyword">let</a> <a id="925" href="ULC.Substitution.html#925" class="Bound">xâ€²</a> <a id="928" class="Symbol">=</a> <a id="930" href="Nominal.Support.html#325" class="Function">freshAtom</a> <a id="940" class="Symbol">(</a><a id="941" href="ULC.Substitution.html#832" class="Bound">xs</a> <a id="944" href="Data.List.Base.html#1819" class="Function Operator">++</a> <a id="947" href="Nominal.Support.html#1453" class="Function">supp</a> <a id="952" href="ULC.Substitution.html#916" class="Bound">t</a><a id="953" class="Symbol">)</a>
                  <a id="973" class="Keyword">in</a> <a id="976" href="ULC.Base.html#748" class="InductiveConstructor Operator">Æ›</a> <a id="978" href="ULC.Substitution.html#925" class="Bound">xâ€²</a> <a id="981" href="ULC.Base.html#748" class="InductiveConstructor Operator">â‡’</a> <a id="983" href="ULC.Substitution.html#799" class="Function">go</a> <a id="986" class="Symbol">(</a><a id="987" href="ULC.Substitution.html#912" class="Bound">x</a> <a id="989" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">âˆ·</a> <a id="991" href="ULC.Substitution.html#832" class="Bound">xs</a><a id="993" class="Symbol">)</a> <a id="995" class="Symbol">(</a><a id="996" href="Nominal.Swap.Base.html#442" class="Field">swap</a> <a id="1001" href="ULC.Substitution.html#925" class="Bound">xâ€²</a> <a id="1004" href="ULC.Substitution.html#912" class="Bound">x</a> <a id="1006" href="ULC.Substitution.html#916" class="Bound">t</a><a id="1007" class="Symbol">)</a>

<a id="1010" class="Keyword">infix</a> <a id="1016" class="Number">6</a> <a id="1018" href="ULC.Substitution.html#1045" class="Function Operator">_[_/_]</a>
<a id="1025" class="Symbol">{-#</a> <a id="1029" class="Keyword">TERMINATING</a> <a id="1041" class="Symbol">#-}</a>
<a id="_[_/_]"></a><a id="1045" href="ULC.Substitution.html#1045" class="Function Operator">_[_/_]</a> <a id="1052" class="Symbol">:</a> <a id="1054" href="ULC.Base.html#356" class="Datatype">Term</a> <a id="1059" class="Symbol">â†’</a> <a id="1061" href="ULC.Substitution.html#404" class="Bound">Atom</a> <a id="1066" class="Symbol">â†’</a> <a id="1068" href="ULC.Base.html#356" class="Datatype">Term</a> <a id="1073" class="Symbol">â†’</a> <a id="1075" href="ULC.Base.html#356" class="Datatype">Term</a>
<a id="1080" class="Symbol">(</a><a id="1081" href="ULC.Base.html#376" class="InductiveConstructor Operator">`</a> <a id="1083" href="ULC.Substitution.html#1083" class="Bound">x</a><a id="1084" class="Symbol">)</a> <a id="1086" href="ULC.Substitution.html#1045" class="Function Operator">[</a> <a id="1088" href="ULC.Substitution.html#1088" class="Bound">ğ•’</a> <a id="1090" href="ULC.Substitution.html#1045" class="Function Operator">/</a> <a id="1092" href="ULC.Substitution.html#1092" class="Bound">N</a> <a id="1094" href="ULC.Substitution.html#1045" class="Function Operator">]</a> <a id="1096" class="Symbol">=</a> <a id="1098" href="Data.Bool.Base.html#1292" class="Function Operator">if</a> <a id="1101" href="ULC.Substitution.html#1083" class="Bound">x</a> <a id="1103" href="Prelude.DecEq.Core.html#222" class="Function Operator">==</a> <a id="1106" href="ULC.Substitution.html#1088" class="Bound">ğ•’</a> <a id="1108" href="Data.Bool.Base.html#1292" class="Function Operator">then</a> <a id="1113" href="ULC.Substitution.html#1092" class="Bound">N</a> <a id="1115" href="Data.Bool.Base.html#1292" class="Function Operator">else</a> <a id="1120" href="ULC.Base.html#376" class="InductiveConstructor Operator">`</a> <a id="1122" href="ULC.Substitution.html#1083" class="Bound">x</a>
<a id="1124" class="Symbol">(</a><a id="1125" href="ULC.Substitution.html#1125" class="Bound">L</a> <a id="1127" href="ULC.Base.html#396" class="InductiveConstructor Operator">Â·</a> <a id="1129" href="ULC.Substitution.html#1129" class="Bound">M</a><a id="1130" class="Symbol">)</a> <a id="1132" href="ULC.Substitution.html#1045" class="Function Operator">[</a> <a id="1134" href="ULC.Substitution.html#1134" class="Bound">ğ•’</a> <a id="1136" href="ULC.Substitution.html#1045" class="Function Operator">/</a> <a id="1138" href="ULC.Substitution.html#1138" class="Bound">N</a> <a id="1140" href="ULC.Substitution.html#1045" class="Function Operator">]</a> <a id="1142" class="Symbol">=</a>
  <a id="1146" class="Keyword">let</a> <a id="1150" href="ULC.Substitution.html#1150" class="Bound">Lâ€²</a> <a id="1153" class="Symbol">=</a> <a id="1155" href="ULC.Substitution.html#1125" class="Bound">L</a> <a id="1157" href="ULC.Substitution.html#1045" class="Function Operator">[</a> <a id="1159" href="ULC.Substitution.html#1134" class="Bound">ğ•’</a> <a id="1161" href="ULC.Substitution.html#1045" class="Function Operator">/</a> <a id="1163" href="ULC.Substitution.html#1138" class="Bound">N</a> <a id="1165" href="ULC.Substitution.html#1045" class="Function Operator">]</a>
      <a id="1173" href="ULC.Substitution.html#1173" class="Bound">Mâ€²</a> <a id="1176" class="Symbol">=</a> <a id="1178" href="ULC.Substitution.html#1129" class="Bound">M</a> <a id="1180" href="ULC.Substitution.html#1045" class="Function Operator">[</a> <a id="1182" href="ULC.Substitution.html#1134" class="Bound">ğ•’</a> <a id="1184" href="ULC.Substitution.html#1045" class="Function Operator">/</a> <a id="1186" href="ULC.Substitution.html#1138" class="Bound">N</a> <a id="1188" href="ULC.Substitution.html#1045" class="Function Operator">]</a>
  <a id="1192" class="Keyword">in</a> <a id="1195" href="ULC.Substitution.html#1150" class="Bound">Lâ€²</a> <a id="1198" href="ULC.Base.html#396" class="InductiveConstructor Operator">Â·</a> <a id="1200" href="ULC.Substitution.html#1173" class="Bound">Mâ€²</a>
<a id="1203" class="Symbol">(</a><a id="1204" href="ULC.Base.html#413" class="InductiveConstructor Operator">Æ›</a> <a id="1206" href="ULC.Substitution.html#1206" class="Bound">tÌ‚</a><a id="1208" class="Symbol">)</a> <a id="1210" href="ULC.Substitution.html#1045" class="Function Operator">[</a> <a id="1212" href="ULC.Substitution.html#1212" class="Bound">ğ•’</a> <a id="1214" href="ULC.Substitution.html#1045" class="Function Operator">/</a> <a id="1216" href="ULC.Substitution.html#1216" class="Bound">N</a> <a id="1218" href="ULC.Substitution.html#1045" class="Function Operator">]</a> <a id="1220" class="Symbol">=</a>
  <a id="1224" class="Comment">-- let y = fresh-var (ğ•’ , tÌ‚ , N)</a>
  <a id="1260" class="Keyword">let</a> <a id="1264" href="ULC.Substitution.html#1264" class="Bound">y</a> <a id="1266" class="Symbol">=</a> <a id="1268" href="Nominal.Support.html#325" class="Function">freshAtom</a> <a id="1278" class="Symbol">(</a><a id="1279" href="ULC.Substitution.html#1212" class="Bound">ğ•’</a> <a id="1281" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">âˆ·</a> <a id="1283" href="Nominal.Support.html#1453" class="Function">supp</a> <a id="1288" href="ULC.Substitution.html#1206" class="Bound">tÌ‚</a> <a id="1291" href="Data.List.Base.html#1819" class="Function Operator">++</a> <a id="1294" href="Nominal.Support.html#1453" class="Function">supp</a> <a id="1299" href="ULC.Substitution.html#1216" class="Bound">N</a><a id="1300" class="Symbol">)</a>
  <a id="1304" class="Keyword">in</a> <a id="1307" href="ULC.Base.html#748" class="InductiveConstructor Operator">Æ›</a> <a id="1309" href="ULC.Substitution.html#1264" class="Bound">y</a> <a id="1311" href="ULC.Base.html#748" class="InductiveConstructor Operator">â‡’</a> <a id="1313" href="Nominal.Abs.Base.html#587" class="Function">conc</a> <a id="1318" href="ULC.Substitution.html#1206" class="Bound">tÌ‚</a> <a id="1321" href="ULC.Substitution.html#1264" class="Bound">y</a> <a id="1323" href="ULC.Substitution.html#1045" class="Function Operator">[</a> <a id="1325" href="ULC.Substitution.html#1212" class="Bound">ğ•’</a> <a id="1327" href="ULC.Substitution.html#1045" class="Function Operator">/</a> <a id="1329" href="ULC.Substitution.html#1216" class="Bound">N</a> <a id="1331" href="ULC.Substitution.html#1045" class="Function Operator">]</a>

<a id="1334" class="Comment">{- ** well-founded version
tâ‚€ [ ğ•’ / s ] = â‰º-rec _ go tâ‚€
  module âˆ£Substitutionâˆ£ where
    go : âˆ€ x â†’ (âˆ€ y â†’ y â‰º x â†’ Term) â†’ Term
    go x rec with x
    ... | ` x   = if x == ğ•’ then s else ` x
    ... | l Â· m = rec l (l Â·â‰ºË¡ m) Â· rec m (l Â·â‰ºÊ³ m)
    -- Cannot simply use `Æ› (mapAbs go f)` here; need well-founded recursion
    -- ... | Æ› f   = Æ› mapAbs-Term f (Î» t tâ‰º â†’ rec t tâ‰º)
    ... | Æ› f =
      let y , _ = fresh (nub $ ğ•’ âˆ· supp f ++ supp s)
      in  Æ› y â‡’ rec (conc f y) (concâ‰º f y)
-}</a>

<a id="1829" class="Comment">-- infix 6 _[_/_]â†‘</a>
<a id="1848" class="Comment">-- _[_/_]â†‘ : Abs Term â†’ Atom â†’ Term â†’ Abs Term</a>
<a id="1895" class="Comment">-- (abs ğ•’ t) [ x / N ]â†‘ = unÆ› $ (Æ› ğ•’ â‡’ t) [ x / N ]</a>

<a id="1948" class="Keyword">postulate</a> <a id="swap-subst"></a><a id="1958" href="ULC.Substitution.html#1958" class="Postulate">swap-subst</a> <a id="1969" class="Symbol">:</a> <a id="1971" href="Nominal.Swap.Equivariance.html#1856" class="Macro">Equivariant</a> <a id="1983" href="ULC.Substitution.html#1045" class="Function Operator">_[_/_]</a>

<a id="1991" class="Comment">{- ** postulate for now...

subs : List (Atom Ã— Term) â†’ Opâ‚ Term
subs = Î» where
  [] t â†’ t
  ((ğ•’ , s) âˆ· Ïƒ) t â†’ subs Ïƒ (t [ ğ•’ / s ])

sub-Î¾ : (L Â· M) [ x / N ] â‰¡ (L [ x / N ]) Â· (M [ x / N ])
sub-Î¾ = refl

sub-Æ› : (Æ› x â‡’ N) [ y / M ] â‰¡
  (let xâ€² = freshAtom (y âˆ· x âˆ· supp N ++ supp M)
   in Æ› xâ€² â‡’ swap xâ€² x N [ y / M ])
sub-Æ› = refl

sub-` : (` x) [ x / N ] â‰¡ N
sub-` {x} rewrite â‰Ÿ-refl x = refl

sub-`-reject : x â‰¢ y â†’ (` x) [ y / N ] â‰¡ ` x
sub-`-reject {x}{y} xâ‰¢y rewrite dec-no (x â‰Ÿ y) xâ‰¢y .projâ‚‚ = refl

-- sub-noop : x âˆ‰ supp t â†’ t [ x / M ] â‰ˆ t
-- sub-noop xâˆ‰ = {!!}

swap-var-helper : âˆ€ x y v z s
  â†’ swap x y (if v == z then s else (` v))
  â‰ˆ swap x y (` v) [ swap x y z / swap x y s ]
swap-var-helper x y v z s
  = case v â‰Ÿ z of Î» where
      (yes vâ‰¡z) â†’ âˆ™vâ‰¡z vâ‰¡z
      (no  vâ‰¢z) â†’ âˆ™vâ‰¢z vâ‰¢z
  where
  âˆ™vâ‰¡z : v â‰¡ z
        â†’ swap x y (if v == z then s else (` v))
        â‰ˆ swap x y (` v) [ swap x y z / swap x y s ]
  âˆ™vâ‰¡z vâ‰¡z rewrite dec-yes (v â‰Ÿ z) vâ‰¡z .projâ‚‚ | vâ‰¡z
    = â‰ˆ-reflexive $ sym $ sub-`

  âˆ™vâ‰¢z : v â‰¢ z
        â†’ swap x y (if v == z then s else (` v))
        â‰ˆ swap x y (` v) [ swap x y z / swap x y s ]
  âˆ™vâ‰¢z vâ‰¢z rewrite dec-no (v â‰Ÿ z) vâ‰¢z .projâ‚‚
    = â‰ˆ-reflexive
    $ sym
    $ sub-`-reject
    $ swap-â‰¢ vâ‰¢z

private
  pattern ğŸ˜ = here refl; pattern ğŸ™ = there ğŸ˜
  pattern ğŸš = there ğŸ™; pattern ğŸ› = there ğŸš
open â‰ˆ-Reasoning

cong-if : âˆ€ {b} â†’
  âˆ™ L â‰ˆ Lâ€²
  âˆ™ M â‰ˆ Mâ€²
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    (if b then L  else M)
  â‰ˆ (if b then Lâ€² else Mâ€²)
cong-if {b = true} = const
cong-if {b = false} _ = id

cong-substË¡ : x â‰ˆ y â†’ t [ x / M ] â‰ˆ t [ y / M ]
cong-substË¡ refl = â‰ˆ-refl

mutual
  {-# TERMINATING #-}
  swap-subst : âˆ€ {x y z : Atom} {s : Term} t â†’
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    swap x y (t [ z / s ]) â‰ˆ swap x y t [ swap x y z / swap x y s ]
  swap-subst {x}{y}{z}{s} t with t
  ... | ` v
    = begin
      swap x y ((` v) [ z / s ])
    â‰¡âŸ¨âŸ©
      swap x y (if v == z then s else (` v))
    â‰ˆâŸ¨ swap-var-helper x y v z s âŸ©
      ` (if v == x then y else if v == y then x else v) [ swap x y z / swap x y s ]
    â‰¡âŸ¨âŸ©
      swap x y (` v) [ swap x y z / swap x y s ]
    âˆ
  ... | L Â· M
    = begin
      swap x y ((L Â· M) [ z / s ])
    â‰¡âŸ¨âŸ©
      swap x y ((L [ z / s ]) Â· (M [ z / s ]))
    â‰¡âŸ¨âŸ©
      swap x y (L [ z / s ]) Â· swap x y (M [ z / s ])
    â‰ˆâŸ¨ Î¾â‰¡ (swap-subst L) (swap-subst M) âŸ©
        (swap x y L [ swap x y z / swap x y s ])
      Â· (swap x y M [ swap x y z / swap x y s ])
    â‰¡âŸ¨âŸ©
      (swap x y L Â· swap x y M) [ swap x y z / swap x y s ]
    â‰¡âŸ¨âŸ©
      swap x y (L Â· M) [ swap x y z / swap x y s ]
    âˆ
  ... | Æ› tÌ‚@(abs ğ•© t)
         --   ğ•©â€² âˆ‰ z âˆ· supp tÌ‚ ++ supp s
         -- â‡’âŸ¨ equivariance of _âˆ‰_ âŸ©
         --   swap x y ğ•©â€² âˆ‰ swap x y (z âˆ· supp tÌ‚ ++ supp s)
         -- â‡’âŸ¨ equivariance on ğ•©â€² âŸ©
         --   ğ•©â€² âˆ‰ -//-
         --   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
         --   âœ“ swap x y ğ•©â€² âˆ‰ swap x y (z âˆ· supp tÌ‚ ++ supp s)
         --     ğ•©â€² âˆ‰ swap x y (z âˆ· supp tÌ‚ ++ supp s)
         --   âœ– ğ•©â€² âˆ‰ swap x y (z âˆ· supp tÌ‚ ++ supp s)
    = {!!}
  {-
    let ğ•©â€² , xâˆ‰ = minFresh (z âˆ· supp tÌ‚ ++ supp s)
        ğ•ªâ€² , yâˆ‰ = minFresh (swap x y z âˆ· supp (swap x y tÌ‚) ++ supp (swap x y s))

        cur-supp : Atoms
        cur-supp = swap x y z âˆ· supp (swap x y tÌ‚) ++ supp (swap x y s)

        xâˆ‰â€² : swap x y ğ•©â€² âˆ‰ cur-supp
        xâˆ‰â€² = Î» where
          (here eq) â†’ swap-â‰¢ (xâˆ‰ âˆ˜ here) eq
          (there xâˆˆ) â†’ case âˆˆ-++â» (supp $ swap x y tÌ‚) xâˆˆ of Î» where
            (injâ‚ xâˆˆ) â†’ -- xâˆˆ : swap x y ğ•©â€² âˆˆ supp (swap x y tÌ‚)
                        -- â‡’? ğ•©â€² âˆˆ supp tÌ‚
              {!!}
            (injâ‚‚ xâˆˆ) â†’ -- xâˆˆ : swap x y ğ•©â€² âˆˆ supp (swap x y s)
                        -- â‡’? ğ•©â€² âˆˆ supp s
              {!!}

        wâˆ‰â€² : w âˆ‰ swap x y ğ•©â€² âˆ· cur-supp
        wâˆ‰â€² = {!!}

        yâˆ‰â€² : ğ•ªâ€² âˆ‰ cur-supp
        yâˆ‰â€² = yâˆ‰

        wâˆ‰â€³ : w âˆ‰ ğ•ªâ€² âˆ· cur-supp
        wâˆ‰â€³ = {!!}
    in begin
      swap x y ((Æ› tÌ‚) [ z / s ])
    â‰¡âŸ¨âŸ©
      swap x y (Æ› ğ•©â€² â‡’ conc tÌ‚ ğ•©â€² [ z / s ])
    â‰¡âŸ¨âŸ©
      Æ› swap x y ğ•©â€² â‡’ swap x y (conc tÌ‚ ğ•©â€² [ z / s ])
    â‰¡âŸ¨âŸ©
      (Æ› (abs (swap x y ğ•©â€²) $ swap x y (conc tÌ‚ ğ•©â€² [ z / s ])))
    â‰ˆâŸ¨ Î¶â‰¡ ((ğ•©â€² âˆ· ğ•ªâ€² âˆ· x âˆ· y âˆ· z âˆ· supp tÌ‚ ++ supp s) , Î» w wâˆ‰ â†’
      -- this is precisely the Abs-isomorphism proof for _Ã—_!
      begin
        conc (abs (swap x y ğ•©â€²) $
          swap x y (conc tÌ‚ ğ•©â€² [ z / s ])) w
      â‰ˆâŸ¨ cong-concâˆ˜abs $ swap-subst (conc tÌ‚ ğ•©â€²) âŸ©
        conc (abs (swap x y ğ•©â€²) $
          swap x y (conc tÌ‚ ğ•©â€²) [ swap x y z / swap x y s ]) w
      â‰ˆâŸ¨ (cong-concâˆ˜abs $ cong-subst $ swap-conc tÌ‚) âŸ©
        conc (abs (swap x y ğ•©â€²) $
          conc (swap x y tÌ‚) (swap x y ğ•©â€²) [ swap x y z / swap x y s ]) w
      â‰ˆâŸ¨ conc-fresh {tÌ‚ = swap x y tÌ‚} xâˆ‰â€² wâˆ‰â€² âŸ©
        conc (swap x y tÌ‚) w [ swap x y z / swap x y s ]
      â‰ˆË˜âŸ¨ conc-fresh {tÌ‚ = swap x y tÌ‚} yâˆ‰â€² wâˆ‰â€³ âŸ©
        conc (abs ğ•ªâ€² (conc (swap x y tÌ‚) ğ•ªâ€² [ swap x y z / swap x y s ])) w
      âˆ)
    âŸ©
      (Æ› (abs ğ•ªâ€² (conc (swap x y tÌ‚) ğ•ªâ€² [ swap x y z / swap x y s ])))
    â‰¡âŸ¨âŸ©
      Æ› ğ•ªâ€² â‡’ conc (swap x y tÌ‚) ğ•ªâ€² [ swap x y z / swap x y s ]
    â‰¡âŸ¨âŸ©
      (Æ› swap x y ğ•© â‡’ swap x y t) [ swap x y z / swap x y s ]
    â‰¡âŸ¨âŸ©
      swap x y (Æ› tÌ‚) [ swap x y z / swap x y s ]
    âˆ
  -}

  -- {-# TERMINATING #-}
  postulate cong-subst : t â‰ˆ tâ€² â†’ t [ x / M ] â‰ˆ tâ€² [ x / M ]
{-
  cong-subst Î½â‰¡ = â‰¡Î±-refl _
  cong-subst (Î¾â‰¡ eqË¡ eqÊ³) = Î¾â‰¡ (cong-subst eqË¡) (cong-subst eqÊ³)
  cong-subst {Æ› tÌ‚}{Æ› tÌ‚â€²}{x}{M} (Î¶â‰¡ (xs , eq)) =
    let ğ•© , xâˆ‰ = minFresh (x âˆ· supp tÌ‚ ++ supp M)
        ğ•ª , yâˆ‰ = minFresh (x âˆ· supp tÌ‚â€² ++ supp M)

        ys = ğ•© âˆ· ğ•ª âˆ· x âˆ· supp tÌ‚ ++ supp tÌ‚â€² ++ supp M ++ xs
        ysË¡ = ğ•© âˆ· x âˆ· supp tÌ‚ ++ supp M
        ysÊ³ = ğ•ª âˆ· x âˆ· supp tÌ‚â€² ++ supp M
        ysâŠ†Ë¡ : ysË¡ âŠ† ys
        ysâŠ†Ë¡ = Î» where
          (here p) â†’ here p
          (there (here p)) â†’ there $â€² there $â€² here p
          (there (there xâˆˆ)) â†’ case âˆˆ-++â» (supp tÌ‚) xâˆˆ of Î» where
            (injâ‚ xâˆˆ) â†’ there $â€² there $â€² there $â€² âˆˆ-++âºË¡ xâˆˆ
            (injâ‚‚ xâˆˆ) â†’ there $â€² there $â€² there $â€²
                        âˆˆ-++âºÊ³ (supp tÌ‚) $ âˆˆ-++âºÊ³ (supp tÌ‚â€²) $ âˆˆ-++âºË¡ xâˆˆ
        ysâŠ†Ê³ : ysÊ³ âŠ† ys
        ysâŠ†Ê³ = Î» where
          (here p) â†’ there $â€² here p
          (there (here p)) â†’ there $â€² there $â€² here p
          (there (there xâˆˆ)) â†’ case âˆˆ-++â» (supp tÌ‚â€²) xâˆˆ of Î» where
            (injâ‚ xâˆˆ) â†’ there $â€² there $â€² there $â€²
                        âˆˆ-++âºÊ³ (supp tÌ‚) $ âˆˆ-++âºË¡ xâˆˆ
            (injâ‚‚ xâˆˆ) â†’ there $â€² there $â€² there $â€²
                        âˆˆ-++âºÊ³ (supp tÌ‚) $ âˆˆ-++âºÊ³ (supp tÌ‚â€²) $ âˆˆ-++âºË¡ xâˆˆ

    in Î¶â‰¡ (ys , Î» z zâˆ‰ â†’
    begin
      conc (abs ğ•© $ conc tÌ‚ ğ•© [ x / M ]) z
    â‰ˆâŸ¨ conc-fresh {tÌ‚ = tÌ‚} xâˆ‰ (zâˆ‰ âˆ˜ ysâŠ†Ë¡) âŸ©
      conc tÌ‚ z [ x / M ]
    â‰ˆâŸ¨ cong-subst
     $ eq z
     $ zâˆ‰ âˆ˜ there âˆ˜â€² there âˆ˜â€² there âˆ˜â€²
       âˆˆ-++âºÊ³ (supp tÌ‚) âˆ˜ âˆˆ-++âºÊ³ (supp tÌ‚â€²) âˆ˜ âˆˆ-++âºÊ³ (supp M)
     âŸ©
      conc tÌ‚â€² z [ x / M ]
    â‰ˆË˜âŸ¨ conc-fresh {tÌ‚ = tÌ‚â€²} yâˆ‰ (zâˆ‰ âˆ˜ ysâŠ†Ê³) âŸ©
      conc (abs ğ•ª $ conc tÌ‚â€² ğ•ª [ x / M ]) z
    âˆ)
-}
  postulate
    conc-fresh :
    --   let ğ•© = freshAtom (x âˆ· supp tÌ‚ ++ supp M) in
      âˆ™ ğ•© âˆ‰ x âˆ· supp tÌ‚ ++ supp M
      âˆ™ z âˆ‰ (ğ•© âˆ· x âˆ· supp tÌ‚ ++ supp M)
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        conc (abs ğ•© $ conc tÌ‚ ğ•© [ x / M ]) z
      â‰ˆ conc tÌ‚ z [ x / M ]
{-
  conc-fresh {ğ•©}{x}{tÌ‚}{M}{z} xâˆ‰ zâˆ‰ =
    begin
      conc (abs ğ•© $ conc tÌ‚ ğ•© [ x / M ]) z
    â‰¡âŸ¨âŸ©
      â¦… z â†” ğ•© â¦† (conc tÌ‚ ğ•© [ x / M ])
    â‰ˆâŸ¨ swap-subst (conc tÌ‚ ğ•©) âŸ©
      â¦… z â†” ğ•© â¦† conc tÌ‚ ğ•© [ â¦… z â†” ğ•© â¦† x / â¦… z â†” ğ•© â¦† M ]
    â‰ˆâŸ¨ cong-substË¡ {t = â¦… z â†” ğ•© â¦† conc tÌ‚ ğ•©} {M = â¦… z â†” ğ•© â¦† M} eq-x âŸ©
      â¦… z â†” ğ•© â¦† conc tÌ‚ ğ•© [ x / â¦… z â†” ğ•© â¦† M ]
    â‰ˆâŸ¨ cong-substÊ³ {t = â¦… z â†” ğ•© â¦† conc tÌ‚ ğ•©} {x = x} eq-M âŸ©
      â¦… z â†” ğ•© â¦† conc tÌ‚ ğ•© [ x / M ]
    â‰ˆâŸ¨ cong-subst $ swap-conc tÌ‚ âŸ©
      conc (â¦… z â†” ğ•© â¦† tÌ‚) (â¦… z â†” ğ•© â¦† ğ•©) [ x / M ]
    â‰¡âŸ¨ cong (Î» â—† â†’ conc (â¦… z â†” ğ•© â¦† tÌ‚) â—† [ x / M ]) $ swapÊ³ z ğ•© âŸ©
      conc (â¦… z â†” ğ•© â¦† tÌ‚) z [ x / M ]
    â‰ˆâŸ¨ cong-subst $ cong-conc eq-tÌ‚ zâˆ‰â€² âŸ©
      conc tÌ‚ z [ x / M ]
    âˆ
    where
      zâˆ‰tÌ‚ : z âˆ‰ supp tÌ‚
      zâˆ‰tÌ‚ = zâˆ‰ âˆ˜ there âˆ˜â€² there âˆ˜â€² âˆˆ-++âºË¡

      xâˆ‰tÌ‚ : ğ•© âˆ‰ supp tÌ‚
      xâˆ‰tÌ‚ = xâˆ‰ âˆ˜ there âˆ˜ âˆˆ-++âºË¡

      eq-x : â¦… z â†” ğ•© â¦† x â‰ˆ x
      eq-x = swap-fresh x (Î» where ğŸ˜ â†’ zâˆ‰ ğŸ™) (Î» where ğŸ˜ â†’ xâˆ‰ ğŸ˜)

      eq-tÌ‚ : â¦… z â†” ğ•© â¦† tÌ‚ â‰ˆ tÌ‚
      eq-tÌ‚ = swap-fresh tÌ‚ zâˆ‰tÌ‚ xâˆ‰tÌ‚

      eq-M : â¦… z â†” ğ•© â¦† M â‰ˆ M
      eq-M = swap-fresh M (zâˆ‰ âˆ˜ there âˆ˜â€² there âˆ˜â€² âˆˆ-++âºÊ³ (supp tÌ‚))
                          (xâˆ‰ âˆ˜ there âˆ˜â€² âˆˆ-++âºÊ³ (supp tÌ‚))

      zâˆ‰â€² : z âˆ‰ eq-tÌ‚ .projâ‚
      zâˆ‰â€² = zâˆ‰ âˆ˜ there âˆ˜â€² there âˆ˜â€² âˆˆ-++âºË¡ âˆ˜ supp-absâŠ† tÌ‚ xâˆ‰tÌ‚ zâˆ‰tÌ‚

  {-# TERMINATING #-}
  cong-substÊ³ : M â‰ˆ Mâ€² â†’ t [ x / M ] â‰ˆ t [ x / Mâ€² ]
  cong-substÊ³ {t = ` _}{x} eq = cong-if {b = _ == x} eq â‰ˆ-refl
  cong-substÊ³ {t = L Â· M} eq = Î¾â‰¡ (cong-substÊ³ {t = L} eq) (cong-substÊ³ {t = M} eq)
  cong-substÊ³ {M}{Mâ€²}{Æ› tÌ‚}{x} eq =
    let ğ•© , xâˆ‰ = minFresh (x âˆ· supp tÌ‚ ++ supp M)
        ğ•ª , yâˆ‰ = minFresh (x âˆ· supp tÌ‚ ++ supp Mâ€²)
        xs = ğ•© âˆ· ğ•ª âˆ· x âˆ· supp tÌ‚ ++ supp M ++ supp Mâ€²
        xsË¡ = ğ•© âˆ· x âˆ· supp tÌ‚ ++ supp M
        xsÊ³ = ğ•ª âˆ· x âˆ· supp tÌ‚ ++ supp Mâ€²
        xsâŠ†Ë¡ : xsË¡ âŠ† xs
        xsâŠ†Ë¡ = Î» where
          (here p) â†’ here p
          (there (here p)) â†’ there $â€² there $â€² here p
          (there (there xâˆˆ)) â†’ case âˆˆ-++â» (supp tÌ‚) xâˆˆ of Î» where
            (injâ‚ xâˆˆ) â†’ there $â€² there $â€² there $â€² âˆˆ-++âºË¡ xâˆˆ
            (injâ‚‚ xâˆˆ) â†’ there $â€² there $â€² there $â€² âˆˆ-++âºÊ³ (supp tÌ‚) $ âˆˆ-++âºË¡ xâˆˆ
        xsâŠ†Ê³ : xsÊ³ âŠ† xs
        xsâŠ†Ê³ = Î» where
          (here p) â†’ there $â€² here p
          (there (here p)) â†’ there $â€² there $â€² here p
          (there (there xâˆˆ)) â†’ case âˆˆ-++â» (supp tÌ‚) xâˆˆ of Î» where
            (injâ‚ xâˆˆ) â†’ there $â€² there $â€² there $â€² âˆˆ-++âºË¡ xâˆˆ
            (injâ‚‚ xâˆˆ) â†’ there $â€² there $â€² there $â€² âˆˆ-++âºÊ³ (supp tÌ‚) $ âˆˆ-++âºÊ³ (supp M) xâˆˆ
    in
    Î¶â‰¡ (xs , Î» z zâˆ‰ â†’
      begin
        conc (abs ğ•© $ conc tÌ‚ ğ•© [ x / M ]) z
      â‰ˆâŸ¨ conc-fresh {tÌ‚ = tÌ‚} {M = M} xâˆ‰ (zâˆ‰ âˆ˜ xsâŠ†Ë¡) âŸ©
        conc tÌ‚ z [ x / M ]
      â‰ˆâŸ¨ cong-substÊ³ {t = conc tÌ‚ z} eq âŸ©
        conc tÌ‚ z [ x / Mâ€² ]
      â‰ˆË˜âŸ¨ conc-fresh {tÌ‚ = tÌ‚} {M = Mâ€²} yâˆ‰ (zâˆ‰ âˆ˜ xsâŠ†Ê³) âŸ©
        conc (abs ğ•ª $ conc tÌ‚ ğ•ª [ x / Mâ€² ]) z
      âˆ)
-}

-}</a>
</pre></body></html>