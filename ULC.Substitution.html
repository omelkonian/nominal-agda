<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>ULC.Substitution</title><link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css'/><style>.github-fork-ribbon:before { background-color: #333; }</style><link rel="stylesheet" href="css/Agda.css"></head><body><a class='github-fork-ribbon'href='https://github.com/omelkonian/nominal-agda/tree/master/ULC/Substitution.agda'data-ribbon='Source code on Github' title='Source code on Github'>Source code on Github</a><pre class="Agda"><a id="1" class="Keyword">open</a> <a id="6" class="Keyword">import</a> <a id="13" href="Prelude.Init.html" class="Module">Prelude.Init</a><a id="25" class="Symbol">;</a> <a id="27" class="Keyword">open</a> <a id="32" href="Prelude.Init.html#397" class="Module">SetAsType</a>
<a id="42" class="Keyword">open</a> <a id="47" class="Keyword">import</a> <a id="54" href="Prelude.General.html" class="Module">Prelude.General</a>
<a id="70" class="Keyword">open</a> <a id="75" class="Keyword">import</a> <a id="82" href="Prelude.DecEq.html" class="Module">Prelude.DecEq</a>
<a id="96" class="Keyword">open</a> <a id="101" class="Keyword">import</a> <a id="108" href="Prelude.DecLists.html" class="Module">Prelude.DecLists</a>
<a id="125" class="Keyword">open</a> <a id="130" class="Keyword">import</a> <a id="137" href="Prelude.Measurable.html" class="Module">Prelude.Measurable</a>
<a id="156" class="Keyword">open</a> <a id="161" class="Keyword">import</a> <a id="168" href="Prelude.InfEnumerable.html" class="Module">Prelude.InfEnumerable</a>
<a id="190" class="Keyword">open</a> <a id="195" class="Keyword">import</a> <a id="202" href="Prelude.Setoid.html" class="Module">Prelude.Setoid</a>

<a id="218" class="Comment">-- ** Substitution.</a>
<a id="238" class="Keyword">module</a> <a id="245" href="ULC.Substitution.html" class="Module">ULC.Substitution</a> <a id="262" class="Symbol">(</a><a id="263" href="ULC.Substitution.html#263" class="Bound">Atom</a> <a id="268" class="Symbol">:</a> <a id="270" href="Agda.Primitive.html#326" class="Primitive">Type</a><a id="274" class="Symbol">)</a> <a id="276" class="Symbol">⦃</a> <a id="278" href="ULC.Substitution.html#278" class="Bound">_</a> <a id="280" class="Symbol">:</a> <a id="282" href="Prelude.DecEq.Core.html#114" class="Record">DecEq</a> <a id="288" href="ULC.Substitution.html#263" class="Bound">Atom</a> <a id="293" class="Symbol">⦄</a> <a id="295" class="Symbol">⦃</a> <a id="297" href="ULC.Substitution.html#297" class="Bound">_</a> <a id="299" class="Symbol">:</a> <a id="301" href="Prelude.InfEnumerable.html#531" class="Record">Enumerable∞</a> <a id="313" href="ULC.Substitution.html#263" class="Bound">Atom</a> <a id="318" class="Symbol">⦄</a> <a id="320" class="Keyword">where</a>

<a id="327" class="Keyword">open</a> <a id="332" class="Keyword">import</a> <a id="339" href="ULC.Base.html" class="Module">ULC.Base</a>    <a id="351" href="ULC.Substitution.html#263" class="Bound">Atom</a> <a id="356" class="Symbol">⦃</a> <a id="358" href="Function.Base.html#4812" class="Function">it</a> <a id="361" class="Symbol">⦄</a>
<a id="363" class="Keyword">open</a> <a id="368" class="Keyword">import</a> <a id="375" href="ULC.Measure.html" class="Module">ULC.Measure</a> <a id="387" href="ULC.Substitution.html#263" class="Bound">Atom</a> <a id="392" class="Symbol">⦃</a> <a id="394" href="Function.Base.html#4812" class="Function">it</a> <a id="397" class="Symbol">⦄</a> <a id="399" class="Symbol">⦃</a> <a id="401" href="Function.Base.html#4812" class="Function">it</a> <a id="404" class="Symbol">⦄</a>
<a id="406" class="Keyword">open</a> <a id="411" class="Keyword">import</a> <a id="418" href="ULC.Alpha.html" class="Module">ULC.Alpha</a>   <a id="430" href="ULC.Substitution.html#263" class="Bound">Atom</a> <a id="435" class="Symbol">⦃</a> <a id="437" href="Function.Base.html#4812" class="Function">it</a> <a id="440" class="Symbol">⦄</a> <a id="442" class="Symbol">⦃</a> <a id="444" href="Function.Base.html#4812" class="Function">it</a> <a id="447" class="Symbol">⦄</a>
<a id="449" class="Keyword">open</a> <a id="454" class="Keyword">import</a> <a id="461" href="Nominal.html" class="Module">Nominal</a> <a id="469" href="ULC.Substitution.html#263" class="Bound">Atom</a>
<a id="474" class="Keyword">open</a> <a id="479" class="Keyword">import</a> <a id="486" href="Nominal.Product.html" class="Module">Nominal.Product</a> <a id="502" href="ULC.Substitution.html#263" class="Bound">Atom</a>

<a id="508" class="Keyword">infix</a> <a id="514" class="Number">6</a> <a id="516" href="ULC.Substitution.html#543" class="Function Operator">_[_/_]</a>
<a id="523" class="Symbol">{-#</a> <a id="527" class="Keyword">TERMINATING</a> <a id="539" class="Symbol">#-}</a>
<a id="_[_/_]"></a><a id="543" href="ULC.Substitution.html#543" class="Function Operator">_[_/_]</a> <a id="550" class="Symbol">:</a> <a id="552" href="ULC.Base.html#326" class="Datatype">Term</a> <a id="557" class="Symbol">→</a> <a id="559" href="ULC.Substitution.html#263" class="Bound">Atom</a> <a id="564" class="Symbol">→</a> <a id="566" href="ULC.Base.html#326" class="Datatype">Term</a> <a id="571" class="Symbol">→</a> <a id="573" href="ULC.Base.html#326" class="Datatype">Term</a>
<a id="578" class="Symbol">(</a><a id="579" href="ULC.Base.html#346" class="InductiveConstructor Operator">`</a> <a id="581" href="ULC.Substitution.html#581" class="Bound">x</a><a id="582" class="Symbol">)</a> <a id="584" href="ULC.Substitution.html#543" class="Function Operator">[</a> <a id="586" href="ULC.Substitution.html#586" class="Bound">𝕒</a> <a id="588" href="ULC.Substitution.html#543" class="Function Operator">/</a> <a id="590" href="ULC.Substitution.html#590" class="Bound">N</a> <a id="592" href="ULC.Substitution.html#543" class="Function Operator">]</a> <a id="594" class="Symbol">=</a> <a id="596" href="Data.Bool.Base.html#1283" class="Function Operator">if</a> <a id="599" href="ULC.Substitution.html#581" class="Bound">x</a> <a id="601" href="Prelude.DecEq.Core.html#188" class="Function Operator">==</a> <a id="604" href="ULC.Substitution.html#586" class="Bound">𝕒</a> <a id="606" href="Data.Bool.Base.html#1283" class="Function Operator">then</a> <a id="611" href="ULC.Substitution.html#590" class="Bound">N</a> <a id="613" href="Data.Bool.Base.html#1283" class="Function Operator">else</a> <a id="618" href="ULC.Base.html#346" class="InductiveConstructor Operator">`</a> <a id="620" href="ULC.Substitution.html#581" class="Bound">x</a>
<a id="622" class="Symbol">(</a><a id="623" href="ULC.Substitution.html#623" class="Bound">L</a> <a id="625" href="ULC.Base.html#366" class="InductiveConstructor Operator">·</a> <a id="627" href="ULC.Substitution.html#627" class="Bound">M</a><a id="628" class="Symbol">)</a> <a id="630" href="ULC.Substitution.html#543" class="Function Operator">[</a> <a id="632" href="ULC.Substitution.html#632" class="Bound">𝕒</a> <a id="634" href="ULC.Substitution.html#543" class="Function Operator">/</a> <a id="636" href="ULC.Substitution.html#636" class="Bound">N</a> <a id="638" href="ULC.Substitution.html#543" class="Function Operator">]</a> <a id="640" class="Symbol">=</a>
  <a id="644" class="Keyword">let</a> <a id="648" href="ULC.Substitution.html#648" class="Bound">L′</a> <a id="651" class="Symbol">=</a> <a id="653" href="ULC.Substitution.html#623" class="Bound">L</a> <a id="655" href="ULC.Substitution.html#543" class="Function Operator">[</a> <a id="657" href="ULC.Substitution.html#632" class="Bound">𝕒</a> <a id="659" href="ULC.Substitution.html#543" class="Function Operator">/</a> <a id="661" href="ULC.Substitution.html#636" class="Bound">N</a> <a id="663" href="ULC.Substitution.html#543" class="Function Operator">]</a>
      <a id="671" href="ULC.Substitution.html#671" class="Bound">M′</a> <a id="674" class="Symbol">=</a> <a id="676" href="ULC.Substitution.html#627" class="Bound">M</a> <a id="678" href="ULC.Substitution.html#543" class="Function Operator">[</a> <a id="680" href="ULC.Substitution.html#632" class="Bound">𝕒</a> <a id="682" href="ULC.Substitution.html#543" class="Function Operator">/</a> <a id="684" href="ULC.Substitution.html#636" class="Bound">N</a> <a id="686" href="ULC.Substitution.html#543" class="Function Operator">]</a>
  <a id="690" class="Keyword">in</a> <a id="693" href="ULC.Substitution.html#648" class="Bound">L′</a> <a id="696" href="ULC.Base.html#366" class="InductiveConstructor Operator">·</a> <a id="698" href="ULC.Substitution.html#671" class="Bound">M′</a>
<a id="701" class="Symbol">(</a><a id="702" href="ULC.Base.html#383" class="InductiveConstructor Operator">ƛ</a> <a id="704" href="ULC.Substitution.html#704" class="Bound">t̂</a><a id="706" class="Symbol">)</a> <a id="708" href="ULC.Substitution.html#543" class="Function Operator">[</a> <a id="710" href="ULC.Substitution.html#710" class="Bound">𝕒</a> <a id="712" href="ULC.Substitution.html#543" class="Function Operator">/</a> <a id="714" href="ULC.Substitution.html#714" class="Bound">N</a> <a id="716" href="ULC.Substitution.html#543" class="Function Operator">]</a> <a id="718" class="Symbol">=</a>
  <a id="722" class="Keyword">let</a> <a id="726" href="ULC.Substitution.html#726" class="Bound">y</a> <a id="728" class="Symbol">=</a> <a id="730" href="Nominal.Support.html#1889" class="Function">fresh-var</a> <a id="740" class="Symbol">(</a><a id="741" href="ULC.Substitution.html#710" class="Bound">𝕒</a> <a id="743" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="745" href="ULC.Substitution.html#704" class="Bound">t̂</a> <a id="748" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="750" href="ULC.Substitution.html#714" class="Bound">N</a><a id="751" class="Symbol">)</a>
  <a id="755" class="Comment">-- let y , _ = minFresh (𝕒 ∷ supp t̂ ++ supp N)</a>
  <a id="805" class="Keyword">in</a> <a id="808" href="ULC.Base.html#718" class="InductiveConstructor Operator">ƛ</a> <a id="810" href="ULC.Substitution.html#726" class="Bound">y</a> <a id="812" href="ULC.Base.html#718" class="InductiveConstructor Operator">⇒</a> <a id="814" href="Nominal.Abs.Base.html#550" class="Function">conc</a> <a id="819" href="ULC.Substitution.html#704" class="Bound">t̂</a> <a id="822" href="ULC.Substitution.html#726" class="Bound">y</a> <a id="824" href="ULC.Substitution.html#543" class="Function Operator">[</a> <a id="826" href="ULC.Substitution.html#710" class="Bound">𝕒</a> <a id="828" href="ULC.Substitution.html#543" class="Function Operator">/</a> <a id="830" href="ULC.Substitution.html#714" class="Bound">N</a> <a id="832" href="ULC.Substitution.html#543" class="Function Operator">]</a>

<a id="835" class="Comment">{- ** well-founded version
t₀ [ 𝕒 / s ] = ≺-rec _ go t₀
  module ∣Substitution∣ where
    go : ∀ x → (∀ y → y ≺ x → Term) → Term
    go x rec with x
    ... | ` x   = if x == 𝕒 then s else ` x
    ... | l · m = rec l (l ·≺ˡ m) · rec m (l ·≺ʳ m)
    -- Cannot simply use `ƛ (mapAbs go f)` here; need well-founded recursion
    -- ... | ƛ f   = ƛ mapAbs-Term f (λ t t≺ → rec t t≺)
    ... | ƛ f =
      let y , _ = fresh (nub $ 𝕒 ∷ supp f ++ supp s)
      in  ƛ y ⇒ rec (conc f y) (conc≺ f y)
-}</a>

<a id="1330" class="Comment">{-
-- specialized version of `mapAbs` for Term
mapAbs-Term : (x&#39; : Abs Term) → (∀ (t : Term) → t ≺ᵐ x&#39; → Term) → Abs Term
mapAbs-Term x&#39; f =
  let a , _ = fresh (supp x&#39; ++ supp?? f)
  in abs a (f (conc x&#39; a) (conc≺ x&#39; a))

-- ⋯ (ƛ f) → ƛ mapAbs _[ 𝕒 / s ] f

-- capture-avoiding application
conc† : Abs Term → Atom → Term
conc† f@(abs x t) y =
  let z , _ = fresh (y ∷ supp f)
  in conc (⦅ x ↔ z ⦆ f) y
-}</a>

<a id="subs"></a><a id="1738" href="ULC.Substitution.html#1738" class="Function">subs</a> <a id="1743" class="Symbol">:</a> <a id="1745" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="1750" class="Symbol">(</a><a id="1751" href="ULC.Substitution.html#263" class="Bound">Atom</a> <a id="1756" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="1758" href="ULC.Base.html#326" class="Datatype">Term</a><a id="1762" class="Symbol">)</a> <a id="1764" class="Symbol">→</a> <a id="1766" href="Algebra.Core.html#475" class="Function">Op₁</a> <a id="1770" href="ULC.Base.html#326" class="Datatype">Term</a>
<a id="1775" href="ULC.Substitution.html#1738" class="Function">subs</a> <a id="1780" class="Symbol">=</a> <a id="1782" class="Symbol">λ</a> <a id="1784" class="Keyword">where</a>
  <a id="1792" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="1795" href="ULC.Substitution.html#1795" class="Bound">t</a> <a id="1797" class="Symbol">→</a> <a id="1799" href="ULC.Substitution.html#1795" class="Bound">t</a>
  <a id="1803" class="Symbol">((</a><a id="1805" href="ULC.Substitution.html#1805" class="Bound">𝕒</a> <a id="1807" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1809" href="ULC.Substitution.html#1809" class="Bound">s</a><a id="1810" class="Symbol">)</a> <a id="1812" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1814" href="ULC.Substitution.html#1814" class="Bound">σ</a><a id="1815" class="Symbol">)</a> <a id="1817" href="ULC.Substitution.html#1817" class="Bound">t</a> <a id="1819" class="Symbol">→</a> <a id="1821" href="ULC.Substitution.html#1738" class="Function">subs</a> <a id="1826" href="ULC.Substitution.html#1814" class="Bound">σ</a> <a id="1828" class="Symbol">(</a><a id="1829" href="ULC.Substitution.html#1817" class="Bound">t</a> <a id="1831" href="ULC.Substitution.html#543" class="Function Operator">[</a> <a id="1833" href="ULC.Substitution.html#1805" class="Bound">𝕒</a> <a id="1835" href="ULC.Substitution.html#543" class="Function Operator">/</a> <a id="1837" href="ULC.Substitution.html#1809" class="Bound">s</a> <a id="1839" href="ULC.Substitution.html#543" class="Function Operator">]</a><a id="1840" class="Symbol">)</a>

<a id="sub-ξ"></a><a id="1843" href="ULC.Substitution.html#1843" class="Function">sub-ξ</a> <a id="1849" class="Symbol">:</a> <a id="1851" class="Symbol">(</a><a id="1852" href="ULC.Base.html#786" class="Generalizable">L</a> <a id="1854" href="ULC.Base.html#366" class="InductiveConstructor Operator">·</a> <a id="1856" href="ULC.Base.html#791" class="Generalizable">M</a><a id="1857" class="Symbol">)</a> <a id="1859" href="ULC.Substitution.html#543" class="Function Operator">[</a> <a id="1861" href="ULC.Base.html#751" class="Generalizable">x</a> <a id="1863" href="ULC.Substitution.html#543" class="Function Operator">/</a> <a id="1865" href="ULC.Base.html#796" class="Generalizable">N</a> <a id="1867" href="ULC.Substitution.html#543" class="Function Operator">]</a> <a id="1869" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="1871" class="Symbol">(</a><a id="1872" href="ULC.Base.html#786" class="Generalizable">L</a> <a id="1874" href="ULC.Substitution.html#543" class="Function Operator">[</a> <a id="1876" href="ULC.Base.html#751" class="Generalizable">x</a> <a id="1878" href="ULC.Substitution.html#543" class="Function Operator">/</a> <a id="1880" href="ULC.Base.html#796" class="Generalizable">N</a> <a id="1882" href="ULC.Substitution.html#543" class="Function Operator">]</a><a id="1883" class="Symbol">)</a> <a id="1885" href="ULC.Base.html#366" class="InductiveConstructor Operator">·</a> <a id="1887" class="Symbol">(</a><a id="1888" href="ULC.Base.html#791" class="Generalizable">M</a> <a id="1890" href="ULC.Substitution.html#543" class="Function Operator">[</a> <a id="1892" href="ULC.Base.html#751" class="Generalizable">x</a> <a id="1894" href="ULC.Substitution.html#543" class="Function Operator">/</a> <a id="1896" href="ULC.Base.html#796" class="Generalizable">N</a> <a id="1898" href="ULC.Substitution.html#543" class="Function Operator">]</a><a id="1899" class="Symbol">)</a>
<a id="1901" href="ULC.Substitution.html#1843" class="Function">sub-ξ</a> <a id="1907" class="Symbol">=</a> <a id="1909" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>

<a id="sub-ƛ"></a><a id="1915" href="ULC.Substitution.html#1915" class="Function">sub-ƛ</a> <a id="1921" class="Symbol">:</a> <a id="1923" class="Symbol">(</a><a id="1924" href="ULC.Base.html#718" class="InductiveConstructor Operator">ƛ</a> <a id="1926" href="ULC.Base.html#751" class="Generalizable">x</a> <a id="1928" href="ULC.Base.html#718" class="InductiveConstructor Operator">⇒</a> <a id="1930" href="ULC.Base.html#796" class="Generalizable">N</a><a id="1931" class="Symbol">)</a> <a id="1933" href="ULC.Substitution.html#543" class="Function Operator">[</a> <a id="1935" href="ULC.Base.html#753" class="Generalizable">y</a> <a id="1937" href="ULC.Substitution.html#543" class="Function Operator">/</a> <a id="1939" href="ULC.Base.html#791" class="Generalizable">M</a> <a id="1941" href="ULC.Substitution.html#543" class="Function Operator">]</a> <a id="1943" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a>
  <a id="1947" class="Symbol">(</a><a id="1948" class="Keyword">let</a> <a id="1952" href="ULC.Substitution.html#1952" class="Bound">x′</a> <a id="1955" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1957" class="Symbol">_</a> <a id="1959" class="Symbol">=</a> <a id="1961" href="Prelude.InfEnumerable.html#1791" class="Function">minFresh</a> <a id="1970" class="Symbol">(</a><a id="1971" href="ULC.Base.html#753" class="Generalizable">y</a> <a id="1973" class="InductiveConstructor Operator">∷</a> <a id="1975" href="ULC.Base.html#751" class="Generalizable">x</a> <a id="1977" class="InductiveConstructor Operator">∷</a> <a id="1979" href="Nominal.Support.html#1313" class="Function">supp</a> <a id="1984" href="ULC.Base.html#796" class="Generalizable">N</a> <a id="1986" href="Data.List.Base.html#1810" class="Function Operator">++</a> <a id="1989" href="Nominal.Support.html#1313" class="Function">supp</a> <a id="1994" href="ULC.Base.html#791" class="Generalizable">M</a><a id="1995" class="Symbol">)</a>
   <a id="2000" class="Keyword">in</a> <a id="2003" href="ULC.Base.html#718" class="InductiveConstructor Operator">ƛ</a> <a id="2005" href="ULC.Substitution.html#1952" class="Bound">x′</a> <a id="2008" href="ULC.Base.html#718" class="InductiveConstructor Operator">⇒</a> <a id="2010" href="Nominal.Swap.Base.html#431" class="Field">swap</a> <a id="2015" href="ULC.Substitution.html#1952" class="Bound">x′</a> <a id="2018" href="ULC.Base.html#751" class="Generalizable">x</a> <a id="2020" href="ULC.Base.html#796" class="Generalizable">N</a> <a id="2022" href="ULC.Substitution.html#543" class="Function Operator">[</a> <a id="2024" href="ULC.Base.html#753" class="Generalizable">y</a> <a id="2026" href="ULC.Substitution.html#543" class="Function Operator">/</a> <a id="2028" href="ULC.Base.html#791" class="Generalizable">M</a> <a id="2030" href="ULC.Substitution.html#543" class="Function Operator">]</a><a id="2031" class="Symbol">)</a>
<a id="2033" href="ULC.Substitution.html#1915" class="Function">sub-ƛ</a> <a id="2039" class="Symbol">=</a> <a id="2041" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>

<a id="2047" class="Comment">-- T0D0: unifying with `conc`</a>
<a id="2077" class="Keyword">infix</a> <a id="2083" class="Number">5</a> <a id="2085" href="ULC.Substitution.html#2090" class="Function Operator">_[_]</a>
<a id="_[_]"></a><a id="2090" href="ULC.Substitution.html#2090" class="Function Operator">_[_]</a> <a id="2095" class="Symbol">:</a> <a id="2097" href="Nominal.Abs.Base.html#400" class="Record">Abs</a> <a id="2101" href="ULC.Base.html#326" class="Datatype">Term</a> <a id="2106" class="Symbol">→</a> <a id="2108" href="ULC.Base.html#326" class="Datatype">Term</a> <a id="2113" class="Symbol">→</a> <a id="2115" href="ULC.Base.html#326" class="Datatype">Term</a>
<a id="2120" href="ULC.Substitution.html#2120" class="Bound">t̂</a><a id="2122" class="Symbol">@(</a><a id="2124" href="Nominal.Abs.Base.html#446" class="InductiveConstructor">abs</a> <a id="2128" href="ULC.Substitution.html#2128" class="Bound">x</a> <a id="2130" href="ULC.Substitution.html#2130" class="Bound">t</a><a id="2131" class="Symbol">)</a> <a id="2133" href="ULC.Substitution.html#2090" class="Function Operator">[</a> <a id="2135" href="ULC.Substitution.html#2135" class="Bound">s</a> <a id="2137" href="ULC.Substitution.html#2090" class="Function Operator">]</a> <a id="2139" class="Symbol">=</a> <a id="2141" href="ULC.Base.html#383" class="InductiveConstructor Operator">ƛ</a> <a id="2143" href="ULC.Substitution.html#2120" class="Bound">t̂</a> <a id="2146" href="ULC.Substitution.html#543" class="Function Operator">[</a> <a id="2148" href="ULC.Substitution.html#2128" class="Bound">x</a> <a id="2150" href="ULC.Substitution.html#543" class="Function Operator">/</a> <a id="2152" href="ULC.Substitution.html#2135" class="Bound">s</a> <a id="2154" href="ULC.Substitution.html#543" class="Function Operator">]</a>

<a id="2157" class="Comment">{-
-- T0D0: fix
-- enforce the Barendregt convention: no shadowing, distinct bound variables
barendregt : Op₁ Term
barendregt = λ where
  (` x)     → ` x
  (l · r)   → barendregt l · barendregt r
  (ƛ a ⇒ t) → ƛ freshen (abs a $ barendregt t)
-}</a>
</pre></body></html>